import os
import json
import time
import sys
from flask import Flask, request, jsonify
from web3 import Web3
from web3.exceptions import ContractCustomError, ContractLogicError

# Add the project root to the Python path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
import config

app = Flask(__name__)

# --- SIMULATED XRPL DID & KYC DATASTORE ---
# This will be populated from gcb_kyc_data.json generated by xrpl_did_kyc_setup.py
simulated_kyc_lookup = {}
KYC_DATA_FILE = "gcb_kyc_data.json"

# EVM Sidechain setup for sending data back to GCBToken contract
w3 = Web3(Web3.HTTPProvider(config.EVM_NETWORK_URL))
deployer_private_key = config.EVM_DEPLOYER_PRIVATE_KEY
if not deployer_private_key.startswith('0x'):
    deployer_private_key = '0x' + deployer_private_key
oracle_account = w3.eth.account.from_key(deployer_private_key) # Oracle uses deployer key for simplicity

gcb_token_contract = None
gcb_token_abi = None

def load_contract_abi():
    try:
        from solcx import compile_standard
        CONTRACT_PATH = os.path.join(os.path.dirname(__file__), '..', 'contracts', 'GCBToken.sol')
        with open(CONTRACT_PATH, 'r') as f:
            contract_content = f.read()
        compiled_sol = compile_standard(
            {"language": "Solidity", "sources": {CONTRACT_PATH: {"content": contract_content}},
             "settings": {"outputSelection": {"*": {"*": ["abi"]}}}},
            solc_version="0.8.20",
            allow_paths=[os.path.dirname(CONTRACT_PATH), os.path.join(os.path.dirname(__file__), '..', 'node_modules', '@openzeppelin')]
        )
        return compiled_sol['contracts'][CONTRACT_PATH]['GCBToken']['abi']
    except Exception as e:
        print(f"Could not compile or load ABI for GCBToken: {e}. Please ensure contracts/GCBToken.sol is correct.")
        sys.exit(1)

def init_oracle():
    global gcb_token_contract, gcb_token_abi, simulated_kyc_lookup

    if not w3.is_connected():
        print(f"Error: Oracle could not connect to EVM network at {config.EVM_NETWORK_URL}")
        sys.exit(1)
    print(f"Oracle connected to EVM network (chain ID: {w3.eth.chain_id}).")

    if not config.ACCESS_CONTROL_CONTRACT_ADDRESS:
        print("ERROR: ACCESS_CONTROL_CONTRACT_ADDRESS (GCBToken address) not set in .env. Please run deploy_gcb_token.py first.")
        sys.exit(1)

    gcb_token_abi = load_contract_abi()
    gcb_token_contract = w3.eth.contract(
        address=config.ACCESS_CONTROL_CONTRACT_ADDRESS,
        abi=gcb_token_abi
    )
    print(f"Oracle connected to GCBToken contract at: {config.ACCESS_CONTROL_CONTRACT_ADDRESS}")

    # Load simulated XRPL DID KYC data
    if os.path.exists(KYC_DATA_FILE):
        with open(KYC_DATA_FILE, "r") as f:
            data = json.load(f)
            for investor in data['investors']:
                simulated_kyc_lookup[investor['xrpl_did']] = investor['kyc_approved']
        print(f"Loaded simulated XRPL DID KYC data from {KYC_DATA_FILE}: {simulated_kyc_lookup}")
    else:
        print(f"WARNING: {KYC_DATA_FILE} not found. Please run xrpl_did_kyc_setup.py first.")


@app.route('/attest-kyc', methods=['POST'])
def attest_kyc():
    if not request.is_json:
        return jsonify({"success": False, "error": "Request must be JSON"}), 400

    data = request.get_json()
    xrpl_did = data.get('xrplDID')
    investor_evm_address = data.get('investorEVMAddress')

    if not all([xrpl_did, investor_evm_address]):
        return jsonify({"success": False, "error": "Missing required fields (xrplDID, investorEVMAddress)"}), 400

    print(f"\nOracle received KYC attestation request for DID: {xrpl_did}, EVM Address: {investor_evm_address}")

    # --- SIMULATED XRPL DID KYC RESOLUTION ---
    # In a real setup, this would involve complex XRPL DID resolution and VC verification.
    kyc_status = simulated_kyc_lookup.get(xrpl_did, False) # Default to False if DID not found

    print(f"  -> KYC Status for {xrpl_did}: {'APPROVED' if kyc_status else 'NOT APPROVED'}")

    # --- SIMULATED AXELAR GMP (Sending KYC status back to EVM) ---
    try:
        print(f"  -> Sending KYC status '{kyc_status}' to GCBToken contract for EVM address: {investor_evm_address}")

        nonce = w3.eth.get_transaction_count(oracle_account.address)
        
        # Call the updateKYCStatus function on the smart contract
        transaction = gcb_token_contract.functions.updateKYCStatus(
            investor_evm_address,
            kyc_status
        ).build_transaction({
            'chainId': w3.eth.chain_id,
            'gasPrice': w3.eth.gas_price,
            'from': oracle_account.address,
            'nonce': nonce,
        })

        signed_txn = w3.eth.account.sign_transaction(transaction, private_key=deployer_private_key)
        tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
        
        # Wait for the transaction receipt
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
        
        if tx_receipt.status == 1:
            print(f"  -> KYC status updated on GCBToken contract. Tx Hash: {tx_hash.hex()}")
            return jsonify({"success": True, "message": "KYC status updated on EVM.", "tx_hash": tx_hash.hex()}), 200
        else:
            print(f"  -> EVM transaction failed for KYC status update. Tx Hash: {tx_hash.hex()}")
            return jsonify({"success": False, "error": "EVM transaction failed for KYC update."}), 500

    except ContractCustomError as e:
        print(f"Contract Custom Error sending KYC status to EVM contract: {e}")
        return jsonify({"success": False, "error": f"Contract Custom Error: {str(e)}"}), 500
    except ContractLogicError as e:
        print(f"Contract Logic Error sending KYC status to EVM contract: {e}")
        return jsonify({"success": False, "error": f"Contract Logic Error: {str(e)}"}), 500
    except Exception as e:
        print(f"Error sending KYC status to EVM contract: {e}")
        return jsonify({"success": False, "error": f"Failed to send KYC status to EVM: {str(e)}"}), 500

if __name__ == '__main__':
    init_oracle()
    print(f"GCB KYC Oracle running on http://localhost:{config.ORACLE_PORT}")
    print("Waiting for /attest-kyc POST requests...")
    app.run(port=config.ORACLE_PORT, debug=False) # Set debug=True for development to auto-reload
